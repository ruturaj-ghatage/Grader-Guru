# -*- coding: utf-8 -*-
'''BE_Segmentation_ocr.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/14PVzLlu3E3FgW_g-dIV3lo9AOR4Nu-0x
'''
from CRAFT.test import word_segmentation
import re
# from langchain import PromptTemplate, LLMChain
from functools import cmp_to_key

import os
from os.path import exists, join, basename, splitext


import sys

import time
import matplotlib
import matplotlib.pylab as plt
# import langchain
# from langchain.llms import CTransformers



import cv2
import numpy as np

from transformers import TrOCRProcessor, VisionEncoderDecoderModel
import requests
from PIL import Image

processor = TrOCRProcessor.from_pretrained('microsoft/trocr-base-handwritten')
model = VisionEncoderDecoderModel.from_pretrained('microsoft/trocr-base-handwritten')
pretrained_model = 'CRAFT\\craft_mlt_25k.pth'
download_dir = 'D:\\BEProject\\ObjectDetection\\images'
def compare(a,b):
  y1=int((a[0]+a[1])/40)
  y2=int((b[0]+b[1])/40)
  x1=int((a[2]+a[3])/40)
  x2=int((b[2]+b[3])/40)
  if(y1>y2):return 1
  elif(y1<y2):return -1
  if(x1>x2):return 1
  elif(x1<x2):return -1
  return 0

def compare2(a,b):
  if(a[1]>b[1]):
    return 1
  elif(a[1]<b[1]):
    return -1
  if(a[0]>b[0]):
    return 1
  elif(a[0]<b[0]):
    return -1
  return 0

def segmentation(image):

  original = image.copy()
  gray = cv2.cvtColor(np.asarray(image), cv2.COLOR_BGR2GRAY)
  thresh = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU)[1]

  horizontal_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (50,1))
  detected_lines = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, horizontal_kernel, iterations=2)
  cnts = cv2.findContours(detected_lines, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
  cnts = cnts[0] if len(cnts) == 2 else cnts[1]
  x=np.asarray(image)
  cnts2=cnts


  vertical_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (1,50))
  detected_lines = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, vertical_kernel, iterations=2)
  cnts = cv2.findContours(detected_lines, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
  cnts = cnts[0] if len(cnts) == 2 else cnts[1]
  x=np.asarray(image)

  for c in cnts:
      cv2.drawContours(x, [c], -1, (255,255,255), 2)
  for c in cnts2:
      cv2.drawContours(x, [c], -1, (255,255,255), 2)
  new_img=x
  gray = cv2.cvtColor(x, cv2.COLOR_BGR2GRAY)
  thresh = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU)[1]
  # Dilate with horizontal kernel
  kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (20,10))
  dilate = cv2.dilate(thresh, kernel, iterations=3)


  # Find contours and remove non-diagram contours
  cnts = cv2.findContours(dilate, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
  cnts = cnts[0] if len(cnts) == 2 else cnts[1]
  i=len(cnts)
  images=[]
  nimages=[]
  tem=[]
  for c in cnts:
    x,y,w,h = cv2.boundingRect(c)
    tem.append([x,y,w,h])
  cnts=tem
  cnts=sorted(cnts,key=cmp_to_key(compare2))
  for c in cnts:
      x,y,w,h = c
      area = w*h
      temp = np.asarray(original)[y:y+h, x:x+w]
      if  area > 20000:
          # cv2.drawContours(dilate, [c], -1, (0,0,0), -1)
          temp = np.asarray(original)[y:y+h, x:x+w]
          images.append(temp)
          temp = new_img[y:y+h, x:x+w]
          nimages.append(temp)
  image=original
  return images,nimages

def ocr(i):
  image = Image.fromarray(i)

  pixel_values = processor(images=image, return_tensors='pt').pixel_values

  generated_ids = model.generate(pixel_values)
  generated_text = processor.batch_decode(generated_ids, skip_special_tokens=True)[0]
  return generated_text

def getlines2(image):

  original = image.copy()
  gray = cv2.cvtColor(np.asarray(image), cv2.COLOR_BGR2GRAY)
  thresh = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU)[1]

  horizontal_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (25,1))
  detected_lines = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, horizontal_kernel, iterations=2)
  cnts = cv2.findContours(detected_lines, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
  cnts = cnts[0] if len(cnts) == 2 else cnts[1]
  x=np.asarray(image)
  se={0}
  for x in cnts:
    #print(x[0][1])
    se.add(x[0][0][1])
  se=list(se)
  se.sort()
  l=0
  imag=[]
  image=original
  for i in se[1:]:
    if(i-l>=15):
      nim=image[max(0,l-5):min(i+10,len(image))]
      # cv2_imshow(nim)
      imag.append(nim)

    l=i

  return imag

def images_to_segments(images1):
  download_dir = 'D:\\BEProject\\ObjectDetection\\images'
  page_number=0
  n=len(images1)

  data={}
  images=[]
  for i in range(0,n):
    page=images1[i]
    # print(page_number)
    im,x=segmentation(page)
    seg=1
    for x in im:
      im_path='p'+str(page_number)+'s'+str(seg)
      
      img_path='D:\\BEProject\\ObjectDetection\\images\\'
      images.append([page_number,seg,im_path])
      # print("!!!!!!!!!!image path",img_path+im_path+'.jpg')
      cv2.imwrite(img_path+im_path+'.jpg',x)
      seg=seg+1
    data[page_number]={'diagrams':[],'text':[]}
    page_number=page_number+1


  return data,images

def segment_to_dict(data,images):
  temp_path='D:\\BEProject\\ObjectDetection\\images\\'
  word_segmentation(pretrained_model, temp_path)
  answers={}
  ques=1
  answers[ques]={'text':[],'diagrams':[]}
  for x in images:
    prev=''
    img=cv2.imread('D:\\BEProject\\ObjectDetection\\images\\'+x[2]+'.jpg')
    tenp_path='D:\\BEProject\\ObjectDetection\\result\\res_'
    f = open(tenp_path+x[2]+'.txt', 'r')
    mylist=[]
    yx={}
    ylist=[]
    sum=0
    for s in f:
      if(len(s)<8):continue
      a,b,c,_,_,d,_,_=s.split(',')
      b=int(b)
      d=int(d)
      a=int(a)
      c=int(c)
      sum=sum+(d-b)*(c-a)
      height, width, _ = img.shape
      b=max(0,b-2)
      a=max(0,a-2)
      d=min(height,d+2)
      c=min(width,c+2)
      mylist.append([b,d,a,c])
      temp=int((b+d)/2)
      temp1=int((b+d)/2+(d-b)/4)
      temp2=int((b+d)/2-(d-b)/4)
      if temp in yx.keys():
        yx[temp][0]=min(a,yx[temp][0])
        yx[temp][1]=max(c,yx[temp][1])
      else:
        yx[temp]=[a,c]
      ylist.append(temp)
      if temp1 in yx.keys():
        yx[temp1][0]=min(a,yx[temp][0])
        yx[temp1][1]=max(c,yx[temp][1])
      else:
        yx[temp1]=[a,c]

      if temp2 in yx.keys():
        yx[temp2][0]=min(a,yx[temp][0])
        yx[temp2][1]=max(c,yx[temp][1])
      else:
        yx[temp2]=[a,c]

    f.close()
    ylist.sort()
    mylist=sorted(mylist, key=cmp_to_key(compare))
    ct=''
    height, width, _ = img.shape
    prev=0
    for tx in ylist:

      if(tx-prev<=40):
        continue
      prev=tx
      y1,y2=tx-25,tx+30
      y1=int(max(0,y1))
      y2=int(min(y2,height))
      x1=yx[tx][0]
      x2=yx[tx][1]
      for temp in range(y1,y2+1):
        if(temp in yx.keys()):
          # print('please work',yx[temp])
          x1=min(x1,yx[temp][0])
          x2=max(x2,yx[temp][1])
      #print(y1,y2,x1,x2)
      line=img[y1:y2,x1:x2]
      text=ocr(line)
      text=text.replace('.','')
      text=text.replace('#','')
      text=text.replace("'",'')
      text=text.replace('(','')
      if text.find('Answer')!=-1:
        ques=ques+1
        answers[ques]={'text':[],'diagrams':[]}
      text=text.replace('Answer','')
      ct=ct+' '+text
      #cv2_imshow(img[y1:y2])
      #cv2_imshow(line)
      #print(text)
    height, width, _ = img.shape
    total=height*width
    #print('text: ',ct)
    #print('ratio: ',sum/total)
    if(sum/total>=0.07):
      # ct=ct.strip()
      # ct=ct[max(0,ct.find(' '))]
      data[x[0]]['text'].append(ct)
      answers[ques]['text'].append(ct)
    elif(sum/total>0.01):
      data[x[0]]['diagrams'].append(img)
      answers[ques]['diagrams'].append(img)
  # for x in answers:
  #   answers[x]['text'][0]=answers[x]['text'][0].strip()

  return data,answers

def data_Ex(input_images):
  image_list=os.listdir((input_images))
  images=[]
  answers={}
  for image_path in image_list:
    image_path=input_images+'\\'+image_path
    print('image path ',image_path)
    im=cv2.imread(image_path)
    images.append(im)
  data,images=images_to_segments(images)
  data,answers=segment_to_dict(data,images)
  for x in answers:
    text=answers[x]['text']
    # answers[x]['text'][0]=text[0][text[0].find(' '):]
  return answers

# for x in answers:
#   text=answers[x]['text']
#   text[0]=text[0][text[0].find(' '):]
#   print(text)

#   for j in answers[x]['diagrams']:
#     cv2.imshow(j)




# llm = CTransformers(model='TheBloke/Mistral-7B-Instruct-v0.1-GGUF', model_file='mistral-7b-instruct-v0.1.Q6_K.gguf', config={'gpu_layers':100,'context_length':1000})



# prompt_template = PromptTemplate.from_template(
#         '''
#         <s> [INST] You will be provided with a model answer text and an input answer. You need to judge the input answer by evaluating it against the model answer on parameters like important points covered, grammatical correctness, and sentence structure. Based on all these factors you need to generate a result of the final score that can be asssigned to the input answer out of 5.

#         Model answer: {answer}
#         Input answer: {input}

#         Return just the final score and nothing else no extra accompanying characters.

#         [/INST]
#         '''
#     )
# chain = LLMChain(prompt=prompt_template, llm=llm)

# model_answers = [
#     'Binary search is an efficient algorithm for finding a target value within a sorted array. It works by repeatedly dividing the search interval in half. If the value of the target element is less than the middle element of the interval, the algorithm narrows the interval to the lower half. If the target value is greater, it narrows it to the upper half. This process continues until the target value is found or the interval is empty. Binary search offers several advantages over other search algorithms, particularly when searching through large sorted datasets: Efficiency: Binary search has a time complexity of O(log n), which means it can quickly find the target element in large datasets. This efficiency is crucial for applications that require fast searching, such as databases and sorting algorithms. Simplicity: The binary search algorithm is relatively simple to implement and understand. It follows a clear and logical process of dividing the search interval in half until the target element is found or the interval is empty. Requires Sorted Data: While requiring the data to be sorted may seem like a limitation, it is also an advantage in certain contexts. If the data is already sorted, binary search can be used directly without the need for additional preprocessing steps. Reduced Number of Comparisons: Binary search reduces the number of comparisons needed to find the target element compared to linear search algorithms. In a dataset with n elements, binary search typically requires log2(n) comparisons, which is much smaller than n in most practical cases. Applicability to Various Data Structures: Although commonly used with arrays, binary search can be adapted to work with other data structures such as trees and graphs, providing a versatile search algorithm for different types of data. Binary search, despite its efficiency and simplicity, has several limitations and disadvantages: Requires Sorted Data: As mentioned earlier, binary search requires the input data to be sorted. If the data is not sorted, binary search cannot be applied directly, and sorting the data adds an additional overhead. Not Suitable for Dynamic Data: Binary search is not suitable for dynamic data structures where elements are frequently inserted or deleted. Maintaining a sorted order in such structures can be challenging and may negate the benefits of binary search. Memory Overhead: While the algorithm itself does not require much additional memory, the need to maintain a sorted array or data structure can lead to increased memory usage, especially for large datasets. Complexity of Implementation for Some Data Structures: While binary search is straightforward to implement for arrays, it can be more complex for other data structures such as trees or graphs. In these cases, additional logic is required to adapt the algorithm to work with the specific data structure. Potential for Bugs: Incorrectly implementing the binary search algorithm can lead to bugs, especially in edge cases or when dealing with boundary conditions. Careful attention is needed to ensure the algorithm behaves correctly in all scenarios. Limited Applicability: Binary search is most effective for searching in sorted arrays or structures where random access is possible. It may not be suitable for all types of data or structures, limiting its applicability in certain scenarios.',
#     '.Dynamic programming (DP) is a method for solving complex problems by breaking them down into simpler subproblems. It involves solving each subproblem only once and storing its solution in a table (usually an array or matrix). This approach avoids redundant calculations and leads to more efficient solutions. The key principle of dynamic programming is to solve each subproblem only once and store its solution for future reference. This is known as the principle of optimality, which states that an optimal solution to a problem contains optimal solutions to its subproblems.',
#     'There are two main approaches to dynamic programming: Top-down approach (Memoization): In this approach, the problem is solved recursively, but with the addition of a memory mechanism (memoization) to store the results of subproblems. This avoids redundant calculations by checking if a subproblem has already been solved before solving it again. Bottom-up approach (Tabulation): In this approach, the problem is solved iteratively, starting from the simplest subproblems and gradually building up to the larger problem. The results of subproblems are stored in a table, and the final solution is computed based on these results.',
#     'Heaps and stacks are both data structures used in computer science, but they serve different purposes and have different advantages. Here are some advantages of a heap over a stack: Dynamic Memory Allocation: Heaps allow for dynamic memory allocation, which means you can allocate memory as needed during program execution. This is useful for storing data structures that need to grow or shrink in size, such as arrays or linked lists. Variable Lifetime: Objects allocated on the heap have a variable lifetime, meaning they can exist beyond the scope of the function that created them. This allows you to create objects that persist even after the function has returned. Efficient Memory Management: Heaps use more sophisticated memory management techniques, such as memory pooling and garbage collection, which can lead to more efficient memory usage compared to stacks. Large Memory Allocation: Heaps can allocate larger amounts of memory than stacks, which are typically limited in size. Flexibility: Heaps offer more flexibility in terms of memory management, allowing you to allocate and deallocate memory in a more dynamic and controlled manner. Overall, the heap is useful for managing memory that needs to be dynamically allocated and deallocated, while the stack is more suitable for managing function call execution and local variable storage.'
# ]

# for x in answers:
#   text=answers[x]['text']
#   text[0]=text[0][text[0].find(' '):]
#   print(text)

#   # for j in answers[x]['diagrams']:
#   #   cv2_imshow(j)

#   input_text = model_answers[x-1]
#   print(input_text)

#   print('marks')
#   print(chain.run(answer=text[0], input=input_text))